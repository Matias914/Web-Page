// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ratings.sql

package sqlc

import (
	"context"
	"time"
)

const addRating = `-- name: AddRating :one
INSERT INTO ratings (user_id, movie_id, rating)
VALUES ($1, $2, $3)
RETURNING user_id, movie_id, rating, created_at
`

type AddRatingParams struct {
	UserID  int64 `json:"user_id"`
	MovieID int64 `json:"movie_id"`
	Rating  int32 `json:"rating"`
}

func (q *Queries) AddRating(ctx context.Context, arg AddRatingParams) (Rating, error) {
	row := q.db.QueryRowContext(ctx, addRating, arg.UserID, arg.MovieID, arg.Rating)
	var i Rating
	err := row.Scan(
		&i.UserID,
		&i.MovieID,
		&i.Rating,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRating = `-- name: DeleteRating :exec
DELETE FROM ratings
WHERE user_id = $1 AND movie_id = $2
`

type DeleteRatingParams struct {
	UserID  int64 `json:"user_id"`
	MovieID int64 `json:"movie_id"`
}

func (q *Queries) DeleteRating(ctx context.Context, arg DeleteRatingParams) error {
	_, err := q.db.ExecContext(ctx, deleteRating, arg.UserID, arg.MovieID)
	return err
}

const getRating = `-- name: GetRating :one
SELECT user_id, movie_id, rating, created_at
FROM ratings
WHERE user_id = $1 AND movie_id = $2
`

type GetRatingParams struct {
	UserID  int64 `json:"user_id"`
	MovieID int64 `json:"movie_id"`
}

func (q *Queries) GetRating(ctx context.Context, arg GetRatingParams) (Rating, error) {
	row := q.db.QueryRowContext(ctx, getRating, arg.UserID, arg.MovieID)
	var i Rating
	err := row.Scan(
		&i.UserID,
		&i.MovieID,
		&i.Rating,
		&i.CreatedAt,
	)
	return i, err
}

const listMoviesRatingsFromUserId = `-- name: ListMoviesRatingsFromUserId :many
SELECT user_id, movie_id, rating, created_at, id, title, synopsis, released_at, poster_url, duration_minutes
FROM ratings AS rat
JOIN movies AS mov
ON (mov.id = rat.movie_id)
WHERE rat.user_id = $1
ORDER BY rat.created_at DESC
LIMIT $2
OFFSET $3
`

type ListMoviesRatingsFromUserIdParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListMoviesRatingsFromUserIdRow struct {
	UserID          int64     `json:"user_id"`
	MovieID         int64     `json:"movie_id"`
	Rating          int32     `json:"rating"`
	CreatedAt       time.Time `json:"created_at"`
	ID              int64     `json:"id"`
	Title           string    `json:"title"`
	Synopsis        string    `json:"synopsis"`
	ReleasedAt      time.Time `json:"released_at"`
	PosterUrl       string    `json:"poster_url"`
	DurationMinutes int32     `json:"duration_minutes"`
}

func (q *Queries) ListMoviesRatingsFromUserId(ctx context.Context, arg ListMoviesRatingsFromUserIdParams) ([]ListMoviesRatingsFromUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listMoviesRatingsFromUserId, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMoviesRatingsFromUserIdRow
	for rows.Next() {
		var i ListMoviesRatingsFromUserIdRow
		if err := rows.Scan(
			&i.UserID,
			&i.MovieID,
			&i.Rating,
			&i.CreatedAt,
			&i.ID,
			&i.Title,
			&i.Synopsis,
			&i.ReleasedAt,
			&i.PosterUrl,
			&i.DurationMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersRatingsFromMovieId = `-- name: ListUsersRatingsFromMovieId :many
SELECT user_id, movie_id, rating, rat.created_at, id, username, password, mail, usr.created_at
FROM ratings AS rat
JOIN users AS usr
ON (usr.id = rat.user_id)
WHERE rat.movie_id = $1
ORDER BY rat.rating DESC
LIMIT $2
OFFSET $3
`

type ListUsersRatingsFromMovieIdParams struct {
	MovieID int64 `json:"movie_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

type ListUsersRatingsFromMovieIdRow struct {
	UserID      int64     `json:"user_id"`
	MovieID     int64     `json:"movie_id"`
	Rating      int32     `json:"rating"`
	CreatedAt   time.Time `json:"created_at"`
	ID          int64     `json:"id"`
	Username    string    `json:"username"`
	Password    string    `json:"password"`
	Mail        string    `json:"mail"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

func (q *Queries) ListUsersRatingsFromMovieId(ctx context.Context, arg ListUsersRatingsFromMovieIdParams) ([]ListUsersRatingsFromMovieIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersRatingsFromMovieId, arg.MovieID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRatingsFromMovieIdRow
	for rows.Next() {
		var i ListUsersRatingsFromMovieIdRow
		if err := rows.Scan(
			&i.UserID,
			&i.MovieID,
			&i.Rating,
			&i.CreatedAt,
			&i.ID,
			&i.Username,
			&i.Password,
			&i.Mail,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRating = `-- name: UpdateRating :one
UPDATE ratings
SET rating = $3
WHERE user_id = $1 AND movie_id = $2
RETURNING user_id, movie_id, rating, created_at
`

type UpdateRatingParams struct {
	UserID  int64 `json:"user_id"`
	MovieID int64 `json:"movie_id"`
	Rating  int32 `json:"rating"`
}

func (q *Queries) UpdateRating(ctx context.Context, arg UpdateRatingParams) (Rating, error) {
	row := q.db.QueryRowContext(ctx, updateRating, arg.UserID, arg.MovieID, arg.Rating)
	var i Rating
	err := row.Scan(
		&i.UserID,
		&i.MovieID,
		&i.Rating,
		&i.CreatedAt,
	)
	return i, err
}
